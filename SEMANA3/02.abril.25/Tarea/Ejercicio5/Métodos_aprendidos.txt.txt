En este documento se explicarÃ¡ algunos de los mÃ©todos implementados en el desarrollo de este programa, mÃ©todos que son nuevos para mi.


ğŸ“Œ .join()

ğŸ”¹ Â¿QuÃ© es?
El mÃ©todo .join() en Python se utiliza para unir elementos de una lista (o cualquier iterable) en una sola cadena de texto, usando un separador que defina.

ğŸ”¹ Sintaxis:
"separador".join(lista_de_cadenas)

ğŸ”¹ En mi cÃ³digo:
productosCadena = "\n".join(f"{nombre}: ${precio}" for nombre, precio in self.productos)
 
-self.productos es una lista de tuplas (nombre, precio)
-El for convierte cada tupla en una cadena como "Pan: $1.5"
-El .join() une todos esos strings separados por un salto de lÃ­nea (\n), generando un bloque de texto legible.

En resumen, .join() sirve para unir muchas cadenas en una sola, lo cuÃ¡l es Ãºtil para mostrar listas de forma ordenada.

=============================================================================================================================================================================

ğŸ“Œ __str__

ğŸ”¹ Â¿QuÃ© es?
__str__ es un mÃ©todo especial en Python que se llama automÃ¡ticamente cuando se utiliza print(objeto) o str(objeto)

ğŸ”¹ Â¿Para quÃ© sirve?
Este devuelve una representaciÃ³n de forma de texto legible del objeto. Muy Ãºtil para imprimir objetos de forma clara.

ğŸ”¹ En mi cÃ³digo(clase Cliente):
def __str__(self):
    return f"ID: {self.id_cliente}, Nombre: {self.nombre}, Contacto: {self.contacto}, Descuento: {self.descuento}"

cuando hago: print(cliente)
Python usa automÃ¡ticamente mi __str__() para mostrar toda la informaciÃ³n del cliente.

En mi clase Pedido: tambiÃ©n se utilizÃ³ para mostrar todos los productos y el total final de manera ordenada.


=============================================================================================================================================================================

ğŸ“Œ Subclases y Superclases

ğŸ”¹ Â¿QuÃ© es una superclase?
Es la clase "base" o "madre" de la que otras clases heredan. 
En mi cÃ³digo: class Cliente, es la superclase

ğŸ”¹ Â¿QuÃ© es una subclase?
Una clase que hereda atributos y mÃ©todos de otra. 
En mi cÃ³digo: class ClienteRegular(Cliente) y class ClienteVIP(Cliente), son las subclases de Cliente

ğŸ”¹ Â¿QuÃ© heredan?
Heredan todos los atributos: id_cliente, nombre, contacto, __str__() y cualquier otro mÃ©todo de la superclase.

ğŸ”¹ Â¿CÃ³mo se personalizan?
Con el constructor (__init__) propio:

def __init__(...):
    super().__init__(...)  # Llama al constructor de la superclase
    self.descuento = 10    # Agrega/modifica atributos especÃ­ficos

Esto permite que cada subclase tenga su propio comportamiento, en este caso diferentes descuentos.

ğŸ”¹ En mi cÃ³digo:
Cliente â†’ No tiene descuento

ClienteRegular â†’ 10% de descuento

ClienteVIP â†’ 15% de descuento

Cada uno define su self.descuento, y cuando se calcula el total del pedido, se aplica ese descuento automÃ¡ticamente, gracias a polimorfismo (cada objeto se comporta segÃºn su tipo, aunque se trate como Cliente).

=============================================================================================================================================================================

ğŸ“Œ Polimorfismo

ğŸ”¹ Â¿QuÃ© es?
El polimorfismo es un principio de la programaciÃ³n orientada a objetos que permite que **diferentes clases que comparten una misma interfaz (o herencia)** puedan comportarse de manera distinta cuando se usan desde una referencia comÃºn.

En otras palabras: un mismo mÃ©todo puede funcionar de forma diferente segÃºn el tipo de objeto que lo estÃ© usando.

ğŸ”¹ En el cÃ³digo:
total *= (1 - self.cliente.get_descuento() / 100)

- self.cliente puede ser un Cliente, ClienteRegular, o ClienteVIP.
- Todos tienen el mÃ©todo get_descuento().
- Cada uno devuelve un valor diferente:
  - Cliente â†’ 0  
  - ClienteRegular â†’ 10  
  - ClienteVIP â†’ 15

Aunque el mÃ©todo get_descuento() se llama igual, el resultado cambia dependiendo del tipo real del cliente.

ğŸ”¹ Â¿Por quÃ© es Ãºtil?
Permite escribir cÃ³digo genÃ©rico, pero que se adapta automÃ¡ticamente al comportamiento especÃ­fico del objeto.  
No hace falta preguntar el tipo de cliente ni usar condicionales.

ğŸ§  Frase resumen:
> â€œCon polimorfismo, los objetos pueden compartir la misma interfaz pero comportarse de forma distinta.â€




